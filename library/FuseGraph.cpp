#include "FuseGraph.hpp"
#include "Basic.hpp"

#include <queue>

namespace RIF {

int fgIndex = 0;

// Constructs sew shift lut for graph
SewDiffs::SewDiffs(Graph &_graph) : graph(_graph) {
  std::cerr << "SewDiffs construction for Graph......\n";

  std::vector<ValueBase *> endValues;
  for (ValueBase *value : graph.values) {
    if (value->outputs.size() == 0)
      endValues.push_back(value);
  }
  std::set<ValueBase *> visited;

  auto pushStackIfNotVisited = [&visited](std::stack<ValueBase *> &stk,
                                          ValueBase *value) -> void {
    if (!visited.count(value))
      stk.push(value);
    visited.insert(value);
  };

  // Start from endValues
  for (ValueBase *endValue : endValues) {
    if (visited.count(endValue))
      continue;
    visited.insert(endValue);
    lut[endValue] = 0;
    std::stack<ValueBase *> stk;
    stk.push(endValue);
    while (!stk.empty()) {
      ValueBase *value = stk.top();
      stk.pop();
      assert(!graph.isOperator(value->id));
      for (auto user : value->outputs) {
        auto op = static_cast<OperatorBase *>(user);
        if (visited.count(op) || op->type == CustomValType::Initialize)
          continue;
        for (auto input : op->inputs)
          pushStackIfNotVisited(stk, input);
        auto output = op->outputs[0];
        pushStackIfNotVisited(stk, output);
        calcSewDiff(op);
        visited.insert(op);
      }
      auto op = static_cast<OperatorBase *>(value->inputs[0]);
      if (!visited.count(op) && op->type != CustomValType::Initialize) {
        for (auto input : op->inputs)
          pushStackIfNotVisited(stk, input);
        auto output = op->outputs[0];
        pushStackIfNotVisited(stk, output);
        calcSewDiff(op);
        visited.insert(op);
      }
    }
  }

  // All operators follows its only output (which is its define)
  for (OperatorBase *op : graph.operators) {
    ValueBase *value = op->outputs[0];
    if (!lut.count(value)) {
      std::cerr << value->id << " not visited\n";
    }
    assert(lut.count(value));
    lut[op] = lut[value];
  }

  std::cerr << "Finish SewDiffs construction =================\n";
}

// Utility to get sew shift difference between 2 values
int SewDiffs::getSewDiff(ValueBase *from, ValueBase *to) {
  if (!from || !to)
    return 0;
  if (isScalarValue(from) || isScalarValue(to))
    return 0;
  if (from->type == CustomValType::OneDBool)
    return 0;
  if (to->type == CustomValType::OneDBool)
    return 0;

  if (to->typeInfo->sew == from->typeInfo->sew)
    return 0;
  if (to->typeInfo->sew.to_int() * 2 == from->typeInfo->sew.to_int())
    return -1;
  if (to->typeInfo->sew.to_int() == from->typeInfo->sew.to_int() * 2)
    return +1;
  return 0;
}

void SewDiffs::calcSewDiff(ValueBase *from, ValueBase *to) {
  assert(from);
  assert(to);
  assert(lut.count(from));

  lut[to] = lut[from] + getSewDiff(from, to);
}

void SewDiffs::calcSewDiff(OperatorBase *op) {
  std::vector<ValueBase *> values;
  ValueBase *pivot = nullptr;
  for (ValueBase *input : op->inputs) {
    assert(input);
    if (lut.count(input))
      pivot = input;
    values.push_back(input);
  }
  ValueBase *output = op->outputs[0];
  if (lut.count(output))
    pivot = output;
  values.push_back(output);

  assert(pivot);
  for (ValueBase *value : values)
    calcSewDiff(pivot, value);
}

FuseGraph::FuseGraph(Graph &graph)
    : graph(graph), id("fused_graph_" + std::to_string(fgIndex++)) {}

void FuseGraph::assignLmul(SewDiffs &sd) {
  // An immediate example on why we need lmul shifting is that an operator
  // widening operator using a value generated by an int8m8 operator. In this
  // case the widening operator will generate value of int16m16 and there are
  // currently no intrinsic function for it.
  // Note: Currently we are assigning the smallest LMUL possible right now, the
  //       range [smallestDiff, largestDiff] is not effecting anything
  //       currently.
  int smallestDiff = INT_MAX;
  int largestDiff = INT_MIN;
  for (OperatorBase *op : operators) {
    smallestDiff = std::min(smallestDiff, sd.lut[op]);
    largestDiff = std::max(largestDiff, sd.lut[op]);
    for (ValueBase *input : op->inputs) {
      smallestDiff = std::min(smallestDiff, sd.lut[input]);
      largestDiff = std::max(largestDiff, sd.lut[input]);
    }
    for (ValueBase *output : op->outputs) {
      smallestDiff = std::min(smallestDiff, sd.lut[output]);
      largestDiff = std::max(largestDiff, sd.lut[output]);
    }
  }

  for (OperatorBase *op : operators) {
    if (op->type == CustomValType::Initialize)
      continue;
    ValueBase *output = op->outputs[0];

    op->typeInfo = op->typeInfo->setLmul(
        *op->typeInfo, getSmallestLmulForSew(op->typeInfo->sew));

    initializeLmul(op);
  }

  if (operators.size() > 1 ||
      (operators.size() == 1 &&
       (*operators.begin())->type != CustomValType::Initialize)) {
    std::cerr << "SewDiff range for " << id << ": " << smallestDiff << ", "
              << largestDiff << "\n";
    std::cerr << "TypeInfo for " << id << "\n";
    for (OperatorBase *op : getOperatorsInTopologicalOrder()) {
      std::cerr << "Op: " << op->id << ", " << op->typeInfo->shortVectorTypeName
                << "\n";
      std::cerr << "Inputs\n";
      for (auto input : op->inputs)
        std::cerr << "\t" << input->id << ", "
                  << input->typeInfo->shortVectorTypeName << "\n";
      std::cerr << "Outputs\n";
      for (auto output : op->outputs)
        std::cerr << "\t" << output->id << ", "
                  << output->typeInfo->shortVectorTypeName << "\n";
    }
    std::cerr << "============================\n";
  }
}

void FuseGraph::add(OperatorBase *op) {
  operators.insert(op);
  assert(graph.isOperator(op->id));

  // Bookkeeping for values that is generated within the FuseGraph
  ValueBase *definedValue = op->outputs[0];

  for (ValueBase *user : definedValue->outputs) {
    OperatorBase *userOp = static_cast<OperatorBase *>(user);
    if (operators.count(userOp)) {
      values.insert(definedValue);
    }
  }

  for (ValueBase *use : op->inputs) {
    OperatorBase *defineOp = static_cast<OperatorBase *>(use->inputs[0]);
    if (operators.count(defineOp)) {
      values.insert(use);
    }
  }
}

/*
  subgraph cluster_food {
      eggs; chicken; ham;
      label="Food";
      graph[style=dotted];
  }
*/
void FuseGraph::generateGraphviz(std::ostream &os) {
  static int index = 0;
  os << "subgraph cluster_" << index++ << " {\n";
  for (auto op : operators) {
    os << op->getNameWithType() << "; ";
  }
  for (auto value : values) {
    os << value->getNameWithType() << "; ";
  }
  os << "\n";
  os << "label=\"" << id << "\";\n";
  os << "graph[style=dotted];\n";
  os << "}\n";
}

std::vector<OperatorBase *> FuseGraph::getOperatorsInTopologicalOrder() {
  std::vector<OperatorBase *> ordering;
  std::queue<OperatorBase *> candidates;
  std::map<OperatorBase *, int> inDegreeCnt;
  for (auto op : operators) {
    for (auto input : op->inputs) {
      if (values.count(input))
        continue;
      inDegreeCnt[op]++;
    }
    if (inDegreeCnt[op] == op->inputs.size())
      candidates.push(op);
  }
  while (!candidates.empty()) {
    auto candidate = candidates.front();
    candidates.pop();
    ordering.push_back(candidate);
    auto output = candidate->outputs[0];
    for (auto user : output->outputs) {
      auto op = static_cast<OperatorBase *>(user);
      if (operators.count(op)) {
        inDegreeCnt[op]++;
        if (inDegreeCnt[op] == op->inputs.size())
          candidates.push(op);
      }
    }
  }
  assert(ordering.size() == operators.size());
  return ordering;
}

void FuseGraph::generateCCode(std::ostream &os) {
  os << "void " << id << "() {\n";
  if (operators.size() == 1) {
    OperatorBase *op = *operators.begin();
    op->generateCCode(os);
  } else {
    size_t loopLength = 0;
    std::map<OperatorBase *, CodeGenForOperator *> codegens;

    for (OperatorBase *op : operators) {
      CodeGenForOperator *codegen =
          new CodeGenForOperator(os, op, *op->typeInfo, op->outputs[0]->length);
      codegens[op] = codegen;

      if (loopLength && loopLength != op->outputs[0]->length) {
        // Currently there won't be multiple node fuse graph that contains
        // reduction node, so all output values should have the same length.
        assert(false &&
               "Operators of a FuseGraph should share the same length");
      }
      loopLength = op->outputs[0]->length;
    }

    for (OperatorBase *op : operators) {
      auto codegen = codegens[op];
      codegen->getRawPointers(op->inputs, op->outputs[0]);
    }

    std::string counter = CodeGenForOperator::getCounter(os, loopLength);

    CodeGenForOperator::getLoopStart(os, counter);
    {
      // Use some random CodeGenForOperator structure for calling getVL
      codegens.begin()->second->getVL(counter);

      // Book keep values loaded
      std::map<ValueBase *, std::string> loadedValues;

      // Load values outside of the fuse graph
      for (OperatorBase *op : operators) {
        auto codegen = codegens[op];
        for (auto p : codegen->opInputs) {
          std::string rawID = p.first;
          ValueBase *input = p.second;
          if (!values.count(input)) {
            if (isOneDValue(input)) {
              loadedValues[input] = loadOneDToVector(os, input, rawID, op);
            } else {
              loadedValues[input] = rawID;
            }
          }
        }
      }

      // Execute the operators in topological order (within the fuse graph)
      // Store intermediate results to loadedValues[]
      for (OperatorBase *op : getOperatorsInTopologicalOrder()) {
        ValueBase *output = op->outputs[0];

        // getIntrinsicArguments()
        std::vector<std::string> args;
        for (ValueBase *input : op->inputs) {
          if (!loadedValues.count(input)) {
            assert(false && "Should have using values loaded");
          }
          args.push_back(loadedValues[input]);
        }

        std::string opResult = genOpString(os, op, args, output);
        loadedValues[output] = opResult;
      }

      // Store results
      for (OperatorBase *op : operators) {
        ValueBase *output = op->outputs[0];
        auto codegen = codegens[op];
        std::string opResult = loadedValues[output];

        storeVectorToOneD(os, codegen->opOutput.first, opResult,
                          codegen->opOutput.second);
      }

      // Increment raw pointer placeholders
      for (OperatorBase *op : operators) {
        auto output = op->outputs[0];
        auto codegen = codegens[op];
        for (auto p : codegen->opInputs) {
          if (isOneDValue(p.second))
            incrementRawPointerByVLEN(os, p.first);
        }
        if (isOneDValue(codegen->opOutput.second))
          incrementRawPointerByVLEN(os, codegen->opOutput.first);
      }
    }
    CodeGenForOperator::getLoopEnd(os);
  }
  os << "}\n";
}

// Filter out operators we should not fuse
bool isFusable(OperatorBase *op) {
  const CustomValType &type = op->type;
  const OperatorAttrT &opAttr = op->opAttr;
  const std::string &typeID = op->typeID;

  if (type == CustomValType::Initialize)
    return false;
  if (opAttr & ReductionOperation || opAttr & LoadOperation ||
      opAttr & StoreOperation)
    return false;
  if (typeID == "vcpop_m" || typeID == "vfirst_m" || typeID == "vmsbf_m" ||
      typeID == "vmsif_m" || typeID == "vmsof_m" || typeID == "viota_m" ||
      typeID == "vid_v")
    return false;
  if (op->opAttr & TailAgnostic || op->opAttr & TailUndisturbed ||
      op->opAttr & MaskAgnostic || op->opAttr & MaskUndisturbed)
    return false;
  return true;
}

FuseGraphs::FuseGraphs(Graph &graph) : graph(graph), sd(graph) {
  std::vector<std::string> ordering =
      graph.getOperatorsInReverseTopologicalOrder();
  std::set<OperatorBase *> fusedOperators;

  for (std::string opID : ordering) {
    OperatorBase *initialOp = graph.operatorLUT[opID];
    if (fusedOperators.count(initialOp))
      continue;

    FuseGraph subgraph(graph);
    subgraph.add(initialOp);
    fusedOperators.insert(initialOp);

    std::stack<OperatorBase *> stk;
    if (isFusable(initialOp))
      stk.push(initialOp);
    while (!stk.empty()) {
      OperatorBase *pivot = stk.top();
      stk.pop();

      assert(graph.isOperator(pivot->id));
      assert(pivot->outputs.size() == 1);
      assert(pivot->outputs[0]);

      ValueBase *definedValue = pivot->outputs[0];
      for (ValueBase *user : definedValue->outputs) {
        assert(graph.isOperator(user->id));
        OperatorBase *op = static_cast<OperatorBase *>(user);
        if (fusedOperators.count(op)) {
          continue;
        }
        if (isFusable(op)) {
          subgraph.add(op);
          if (!fusedOperators.count(op)) {
            stk.push(op);
          }
          fusedOperators.insert(op);
        }
      }

      for (ValueBase *use : pivot->inputs) {
        assert(use);
        ValueBase *definer = use->inputs[0];
        assert(graph.isOperator(definer->id));
        if (definer->type == CustomValType::Initialize)
          continue;
        OperatorBase *op = static_cast<OperatorBase *>(definer);
        if (fusedOperators.count(op))
          continue;
        if (isFusable(op)) {
          subgraph.add(op);
          if (!fusedOperators.count(op))
            stk.push(op);
          fusedOperators.insert(op);
        }
      }
    }

    // Add operator into reverse look-up in FusedGraphs
    for (OperatorBase *op : subgraph.operators)
      operatorLUT[op] = subgraphs.size();

    subgraphs.emplace_back(subgraph);
  }
}

std::vector<int> FuseGraphs::getFuseGraphsInTopologicalOrder() {
  std::vector<int> ordering;
  std::map<int, int> inDegreeCnt;
  std::map<int, int> inDegreeTotal;
  std::queue<int> candidates;
  int numOfSubGraph = subgraphs.size();
  for (int i = 0; i < numOfSubGraph; ++i) {
    FuseGraph &fg = subgraphs[i];
    int total = 0;
    for (auto op : fg.operators) {
      for (auto input : op->inputs) {
        if (!fg.values.count(input))
          ++total;
      }
    }
    inDegreeTotal[i] = total;
    if (inDegreeTotal[i] == 0)
      candidates.push(i);
  }
  while (!candidates.empty()) {
    int candidate = candidates.front();
    candidates.pop();
    ordering.push_back(candidate);
    FuseGraph &fromFg = subgraphs[candidate];
    for (auto op : fromFg.operators) {
      auto output = op->outputs[0];
      for (auto user : output->outputs) {
        auto userOp = static_cast<OperatorBase *>(user);
        if (!fromFg.operators.count(userOp)) {
          int toFgIdx = operatorLUT[userOp];
          inDegreeCnt[toFgIdx]++;
          if (inDegreeCnt[toFgIdx] == inDegreeTotal[toFgIdx]) {
            candidates.push(toFgIdx);
          }
        }
      }
    }
  }
  assert(ordering.size() == numOfSubGraph);
  return ordering;
}

void FuseGraphs::generateGraphviz(std::ostream &os) {
  os << "digraph{\n";
  for (auto subgraph : subgraphs)
    subgraph.generateGraphviz(os);
  for (auto op : graph.operators)
    os << op->getNameWithType() << "[shape=oval]\n";
  for (auto value : graph.values)
    os << value->getNameWithType() << "[shape=rectangle]\n";
  for (auto value : graph.values) {
    if (value->inputs[0] == nullptr) {
      std::cerr << "Value '" << value->id
                << "'-'s definer is not set, abort.\n";
      exit(1);
    }
    os << value->inputs[0]->getNameWithType() << " -> "
       << value->getNameWithType() << "\n";
    for (auto user : value->outputs)
      os << value->getNameWithType() << " -> " << user->getNameWithType()
         << "\n";
  }
  os << "}\n";
}

void FuseGraphs::generateCCode(std::ostream &os, uint32_t seed) {
  placeholderIndex = 0;
  graph.emitHeader(os);
  for (auto value : graph.values)
    value->generateCCode(os);
  std::set<int> fgGenerated;
  fgGenerated.clear();

  auto opOrdering = graph.getOperatorsInTopologicalOrder(seed);
  auto fgOrdering = getFuseGraphsInTopologicalOrder();
  for (int fgIdx : fgOrdering) {
    if (fgGenerated.count(fgIdx))
      continue;
    fgGenerated.insert(fgIdx);
    FuseGraph &fg = subgraphs[fgIdx];
    std::cerr << "Generate function for " << fg.id << "\n";
    // The reason why we adjust the LMUL here is that different subgraph-s share
    // the same `Value` in between. Adjusting the LMUL at FuseGraphs creation
    // will let `Value`-s be only suitable for emission of the last sub-graph
    // called to them. Therefore we should assign LMUL right before each
    // FuseGraph code generation.
    fg.assignLmul(sd);

    fg.generateCCode(os);
  }

  // generate function calls for verify golden
  for (auto id : opOrdering) {
    auto op = graph.operatorLUT[id];
    // Note: RIF is still generating golden check function for debug purpose.
    // The function will not be called since fused_gen runs under "short"
    // mode.
    os << "int golden_" << op->getNameWithType() << "() {\n";
    generateVerificationCode(os, op);
    os << "}\n";
  }

  // start of main function
  os << "int main () {\n";
  // call fuseGraph in topological order
  fgGenerated.clear();
  for (int fgIdx : fgOrdering) {
    if (fgGenerated.count(fgIdx))
      continue;
    fgGenerated.insert(fgIdx);
    FuseGraph &fg = subgraphs[fgIdx];
    os << fg.id << "();\n";
  }

  // verify
  for (auto id : opOrdering) {
    auto op = graph.operatorLUT[id];
    // Note: For 'short' mode, RIF will only generate verification only for
    // values that are non-intermediate results.
    if (VerificationMode == "short" && op->outputs[0]->outputs.size() != 0)
      continue;
    os << "printf(\"" << id << " : %s\\n\", golden_" << op->getNameWithType()
       << "() ? \"pass\" : \"fail\");\n";
  }
  // end of main function
  os << "return 0; }\n";
}

} // namespace RIF
